Access Grants {#grants}
=====================

## Overview ## {#grants-overview}

[=Access Grants=] represent an [=Agent's=] decision to grant access to 
some portion of the data in their control to another [=Agent=]. They provide
the context needed to effectively manage permissions on a given [=Agent's=]
data through a compatible access control system.

There are two types of [=Access Grants=]:

* [=Trusted Grants=] are made when a given [=Agent=] trusts another [=Agent=] 
    with expanded, administrative-level privilege to the data in their control.
* [=Data Grants=] are made when a given [=Agent=] wishes to share access 
    to certain types or specific instances of data in their control.

[=Access Grants=] are recorded in an Agent's [=Access Grant Registry=].

[=Access Invitations=] represent [=Access Grants=] made to [=Agents=] with
unknown or yet-to-be established [=identities=].

## Data Model ## {#grants-datamodel}

### Summary ### {#grants-datamodel-summary}

<figure id="fig-grants-model">
  <img src="diagrams/grants-model.svg" width=100%/>
  <figcaption>Data model for the access registry</figcaption>
</figure>

An [=Agent=] links to [=Access Grant Registry Sets=]
via the [interop:hasAccessGrantRegistrySet](interop.ttl#hasAccessGrantRegistrySet) property.

An [=Access Grant Registry Set=] links to any number of [=Access Grant Registries=]
via the [interop:hasRegistry](interop.ttl#hasRegistry) property.

An [=Access Grant Registry=] links to any number of registered [=Access Grants=]
and [=Access Invitations=] via the
[interop:hasRegistration](interop.ttl#hasRegistration) property.

<figure id="fig-grants-agent">
  <figcaption>[=Agent=] at https://alice.pod.example/profile/id#me
  linking to an [=Access Grant Registry Set=]</figcaption>
  <pre highlight="turtle">
  <#me>
    a interop:Agent;
    interop:hasAccessGrantRegistrySet &lt;https://alice.pod.example/profile/grant#set&gt; .
  </pre>
  </figure>
</figure>

<figure id ="fig-grants-registry-set">
   <figcaption>An [=Access Grant Registry Set=] at
   https://alice.pod.example/profile/grant#set linking to two different
  [=Access Grant Registries=]</figcaption>
  <pre highlight="turtle">
  <#set>
    a interop:AccessGrantRegistrySet;
    interop:hasRegistry &lt;https://alice.pod.example/grants/#registry&gt; ,
                    &lt;https://alice.otherpod.example/grants/#registry&gt; .
  </pre>
</figure>

<figure id="fig-grants-registry">
  <figcaption>An [=Access Grant Registry=] at https://alice.pod.example/grants/#registry
  linking to several registered [=Access Grants=] or
  [=Access Invitations=]</figcaption>
  <pre highlight="turtle">
  <#registry>
    a interop:AccessGrantRegistry ;
    interop:hasRegistration &lt;ab3d0023-3860-4358-ae33-8d3af1097b9d#grant&gt; ,
                        &lt;ad7b935f-ced9-4ce6-835f-5c6abc046228#grant&gt; ,
                        &lt;5ed73c65-ce77-4c8a-8f7e-9715b90307e6#grant&gt; ,
                        &lt;2d575cba-3f6c-4c58-bccd-0e6266ba56cf#invitation&gt; .
  </pre>
</figure>

<figure id="fig-grants-grant">
  <figcaption>An [=Access Grant=] at
  https://alice.pod.example/grants/ab3d0023-3860-4358-ae33-8d3af1097b9d#grant
  </figcaption>
  <pre highlight="turtle">
  <#grant>
    a interop:AccessGrant ;
    interop:registeredBy https://alice.pod.example/profile/id#me ;
    interop:registeredWith https://trusted.example/id#agent ;
    interop:registeredAt "2020-09-05T06:15:01Z"^^xsd:dateTime ;
    interop:updatedAt "2020-09-05T06:15:01Z"^^xsd:dateTime ;
    interop:hasAccessGrantSubject <#grant-subject> ;
    interop:hasCompiledAccessGroup <#cag-notebook-group> ;
    interop:hasDataGrant <#notebook-grant>, <#note-grant> .

  <#grant-subject>
    a interop:AccessGrantSubject ;
    interop:accessByAgent https://alice.pod.example/profile/id#me ;
    interop:accessByApplication https://nevernote.example/id#agent .

  <#notebook-grant>
    a interop:DataGrant ;
    interop:hasRegistration data:notebook-tree ;
    interop:registeredShapeTree note:notebook-tree ;
    interop:satisfiesCompiledAccess <#ca-notebook> ;
    interop:accessMode acl:Read, acl:Write ;
    interop:scopeOfDataGrant interop:AllInstances, interop:AllRemote ;

  <#note-grant>
    a interop:DataGrant ;
    interop:hasRegistration data:note-tree ;
    interop:registeredShapeTree note:note-tree ;
    interop:satisfiesCompiledAccess <#ca-note> ;
    interop:accessMode acl:Read, acl:Write ;
    interop:scopeOfDataGrant interop:AllInstances, interop:AllRemote ;

  <#cag-notebook-group>
    a interop:CompiledAccessGroup ;
    interop:fromAccessNeedGroup ex:accessNotebookGroup ;
    interop:hasAccessNeedGroupDecorator ex:accessNotebookGroupDecorator ;
    interop:accessNecessity interop:AccessRequired ;
    interop:authenticatesAs interop:Pilot ;
    interop:hasCompiledAccess <#ca-notebook> .

  <#ca-notebook>
      a interop:CompiledAccess ;
      interop:registeredShapeTree note:notebook-tree ;
      interop:accessMode acl:Read, acl:Write ;
      interop:accessNecessity interop:AccessRequired ;
      interop:hasAccessNeedDecorator ex:notebookAccessDecorator ;
      interop:hasShapeTreeDecorator note:notebookDecorator ;
      interop:referencesCompiledAccess <#ca-notes> ;
      interop:hasDataGrant <#notebook-grant> .

  <#ca-note>
      a interop:CompiledAccess ;
      interop:registeredShapeTree note:note-tree ;
      interop:accessMode acl:Read, acl:Write ;
      interop:accessNecessity interop:AccessRequired ;
      interop:hasAccessNeedDecorator ex:noteAccessDecorator ;
      interop:hasShapeTreeDecorator note:noteDecorator ;
      interop:hasDataGrant <#note-grant> .
  </pre>
</figure>

<figure id="fig-grants-invitation">
  <figcaption>An [=Access Invitation=] at
  https://alice.pod.example/grants/2d575cba-3f6c-4c58-bccd-0e6266ba56cf/#invitation
  </figcaption>
  <pre highlight="turtle">
  <#invitation>
    a interop:AccessInvitation ;
    interop:registeredBy https://alice.pod.example/profile/id#me ;
    interop:registeredWith https://trusted.example/id#agent ;
    interop:registeredAt "2020-09-13T19:32:52Z"^^xsd:dateTime ;
    interop:updatedAt "2020-09-13T19:32:52Z"^^xsd:dateTime ;
    interop:expiresAt "2020-09-20T19:32:52Z"^^xsd:dateTime ;
    interop:hasCompiledAccessGroup <#cag-notebook-group> ;
    interop:hasDataGrant <#notebook-grant>, <#note-grant> ;
    interop:hasAccessInvitationChannel <#phone-channel>, <#email-channel> .

  <#phone-channel>
    a interop:PhoneInvitationChannel ;
    interop:channelTarget "(555) 555-1212" ;
    interop:channelCode "654345" ;
    interop:isValidated false ;
    interop:remainingAttempts 3 .

  <#email-channel>
    a interop:EmailInvitationChannel ;
    interop:channelTarget "bob@example.com" ;
    interop:channelCode "434567" ;
    interop:isValidated true ;
    interop:remainingAttempts 3 .

  <#notebook-grant>
    a interop:DataGrant ;
    interop:hasRegistration data:notebook-tree ;
    interop:registeredShapeTree note:notebook-tree ;
    interop:satisfiesCompiledAccess <#ca-notebook> ;
    interop:accessMode acl:Read, acl:Write ;
    interop:scopeOfDataGrant interop:AllInstances ;

  <#note-grant>
    a interop:DataGrant ;
    interop:hasRegistration data:note-tree ;
    interop:registeredShapeTree note:note-tree ;
    interop:satisfiesCompiledAccess <#ca-note> ;
    interop:accessMode acl:Read, acl:Write ;
    interop:scopeOfDataGrant interop:AllInstances ;

  <#cag-notebook-group>
    a interop:CompiledAccessGroup ;
    interop:fromAccessNeedGroup ex:accessNotebookGroup ;
    interop:hasAccessNeedGroupDecorator ex:accessNotebookGroupDecorator ;
    interop:accessNecessity interop:AccessRequired ;
    interop:authenticatesAs interop:Pilot ;
    interop:hasCompiledAccess <#ca-notebook> .

  <#ca-notebook>
      a interop:CompiledAccess ;
      interop:registeredShapeTree note:notebook-tree ;
      interop:accessMode acl:Read, acl:Write ;
      interop:accessNecessity interop:AccessRequired ;
      interop:hasAccessNeedDecorator ex:notebookAccessDecorator ;
      interop:hasShapeTreeDecorator note:notebookDecorator ;
      interop:referencesCompiledAccess <#ca-notes> ;
      interop:hasDataGrant <#notebook-grant> .

  <#ca-note>
      a interop:CompiledAccess ;
      interop:registeredShapeTree note:note-tree ;
      interop:accessMode acl:Read, acl:Write ;
      interop:accessNecessity interop:AccessRequired ;
      interop:hasAccessNeedDecorator ex:noteAccessDecorator ;
      interop:hasShapeTreeDecorator note:noteDecorator ;
      interop:hasDataGrant <#note-grant> .
  </pre>
</figure>

### Access Grant Registry Set ### {#datamodel-access-registry-set}

An <dfn>Access Grant Registry Set</dfn> is a [=Registry Set=] specifically
made up of [=Access Grant Registries=].

<table class="classinfo data" align="left" id="classAccessGrantRegistrySet">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr>
      <th colspan=3 text-align=left>
        [AccessGrantRegistrySet](interop.ttl#AccessGrantRegistrySet)
        a rdfs:subClassOf [RegistrySet](interop.ttl#RegistrySet)
      </th>
    </tr>
    <tr>
      <th>Property</th>
      <th>Range</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>hasRegistry</td>
      <td>[Registry](interop.ttl#Registry)</td>
      <td>Link to associated [=Access Grant Registries=]</td>
    </tr>
  </tbody>
</table>

The [AccessGrantRegistrySetShape](#shexAccessGrantRegistrySet) is used to validate
an instance of the [AccessGrantRegistrySet](#classAccessGrantRegistrySet) class.

<pre highlight="turtle" id="shexAccessGrantRegistrySet">
<#AccessGrantRegistrySetShape> {
  a [ interop:AccessGrantRegistrySet ] ;
  interop:hasRegistry IRI+
}
</pre>

The [AccessGrantRegistrySetTree](interop.tree#AccessGrantRegistrySetTree)
is assigned to a resource to ensure it will validate against the
[AccessGrantRegistrySetShape](#shexAccessGrantRegistrySet).

<pre highlight="turtle" id="treeAccessGrantRegistrySet">
<#AccessGrantRegistrySetTree>
  a st:ShapeTree;
  st:expectsType st:ShapeTreeResource ;
  st:validatedBy &lt;interops#AccessGrantRegistrySetShape&gt; ;
  st:matchesUriTemplate "access" .
</pre>

### Access Grant Registry ### {#datamodel-access-registry}

An <dfn>Access Grant Registry</dfn> is a collection of
[=Access Grants=] stored in a specific location in a [=pod=].

<table class="classinfo data" align="left" id="classAccessGrantRegistry">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr>
      <th colspan=3>
        [AccessGrantRegistry](interop.ttl#AccessGrantRegistry)
        a rdfs:subClassOf [[#datamodel-agent|Registry]]
      </th>
    </tr>
    <tr>
      <th>Property</th>
      <th>Range</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>hasRegistration</td>
      <td>[Registration](interop.ttl#Registration)</td>
      <td>Link to associated [=Access Grants=]</td>
    </tr>
  </tbody>
</table>

The [AccessGrantRegistryShape](#shexAccessGrantRegistry) is used to validate an
instance of the [AccessGrantRegistry](#classAccessGrantRegistry) class.

<pre highlight="turtle" id="shexAccessGrantRegistry">
<#AccessGrantRegistryShape> {
  a [ interop:AccessGrantRegistry ] ;
  interop:hasRegistration IRI*
}
</pre>

The [AccessGrantRegistryTree](interop.tree#AccessGrantRegistryTree) is assigned
to a container resource to ensure that it will validate against the
[AccessGrantRegistryShape](#shexAccessGrantRegistry), and contain only
conformant instances of the [AccessGrantTree](#treeAccessGrant) and
[AccessInvitationTree](#treeAccessInvitation).

<pre highlight="turtle" id="treeAccessGrantRegistry">
<#AccessGrantRegistryTree>
  a st:ShapeTree;
  st:expectsType st:ShapeTreeContainer ;
  st:validatedBy &lt;interops#AccessGrantRegistryShape&gt; ;
  st:contains <#AccessGrantTree> ,
              <#AccessInvitationTree> ,
              st:AllowNone .
</pre>

### Access Grant ### {#datamodel-access-grant}

Each <dfn>Access Grant</dfn> represents access granted to one recipient; the
[=Access Grant Subject=], based on access criteria detailed in one or more
[=Compiled Access Groups=]. 

Access may be granted to registered data in
[=Data Registries=] through [=Data Grants=]. 

Access may be granted to resources in [=Remote Data Registries=] through
[=Remote Data Grants=].

Elevated access to [=registries=], [=registry sets=], or the [=identity=]
of the [=Agent=] may be granted through [=Trusted Grants=].

<table class="classinfo data" align="left" id="classAccessGrant">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr>
      <th colspan=3>
        [AccessGrant](interop.ttl#AccessGrant)
        a rdfs:subClassOf [Registration](interop.ttl#Registration)
      </th>
    </tr>
    <tr>
      <th>Property</th>
      <th>Range</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>registeredBy</td>
      <td>[Agent](#classAgent)</td>
      <td>[=Agent=] that registered the [=Access Grant=]</td>
    </tr>
    <tr>
      <td>registeredWith</td>
      <td>[Application](#classApplication)</td>
      <td>[=Application=] used to create the [=Access Grant=]</td>
    </tr>
    <tr>
      <td>registeredAt</td>
      <td>xsd:dateTime</td>
      <td>Date and time the [=Access Grant=] was created</td>
    </tr>
    <tr>
      <td>updatedAt</td>
      <td>xsd:dateTime</td>
      <td>Date and time the [=Access Grant=] was updated</td>
    </tr>
    <tr>
      <td>hasAccessGrantSubject</td>
      <td>[AccessGrantSubject](#classAccessGrantSubject)</td>
      <td>Links to one [=Access Grant Subject=] who was granted access.</td>
    </tr>
    <tr>
      <td>hasCompiledAccessGroup</td>
      <td>[CompiledAccessGroup](#classCompiledAccessGroup)</td>
      <td>Links to a [=Compiled Access Group=] associated with the Access Grant.</td>
    </tr>
    <tr>
      <td>hasDataGrant</td>
      <td>[DataGrant](#classDataGrant)</td>
      <td>Links to a [=Data Grant=] associated with the Access Grant.</td>
    </tr>
    <tr>
      <td>hasTrustedGrant</td>
      <td>[TrustedGrant](#classTrustedGrant)</td>
      <td>Links to a [=Trusted Grant=] associated with the Access Grant.</td>
    </tr>
    <tr>
      <td>hasRemoteDataGrant</td>
      <td>[RemoteDataGrant](#classRemoteDataGrant)</td>
      <td>Links to a [=Remote Data Grant=] associated with the Access Grant.</td>
    </tr>
  </tbody>
</table>

The [AccessGrantShape](#shexAccessGrant) is used to validate an instance
of the [AccessGrant](#classAccessGrant) class.

<pre highlight="turtle" id="shexAccessGrant">
<#AccessGrantShape> {
  a [ interop:AccessGrant ] ;
  interop:registeredBy IRI ;
  interop:registeredWith IRI? ;
  interop:registeredAt xsd:dateTime ;
  interop:accessGrantSubject @AccessGrantSubject ;
  interop:hasCompiledAccessGroup @CompiledAccessGroupShape+ ;
  ( interop:hasDataGrant @<#:DataGrantShape>+ |
  interop:hasTrustedGrant @<#:TrustedGrantShape>+ | 
  interop:hasRemoteDataGrant @<#:RemoteDataGrantShape>+ )
}
</pre>

The [AccessGrantTree](interop.tree#AccessGrantTree) is assigned to a
resource via the [AccessGrantRegistryTree](#treeAccessGrantRegistry), and ensure
that the assigned resource will validate against the
[AccessGrantShape](#shexAccessGrant).

<pre highlight="turtle" id="treeAccessGrant">
<#AccessGrantTree>
  a st:ShapeTree;
  st:expectsType st:ShapeTreeResource ;
  st:validatedBy &lt;interops#AccessGrantShape&gt; ;
  st:matchesUriTemplate "{id}" .
</pre>

### Access Grant Subject ### {#datamodel-access-grant-subject}

An <dfn>Access Grant Subject</dfn> represents a unique combination of
who and what is being granted access. For example, it allows a single [=Agent=]
to be specified, or a given [=Agent=] using a given [=Application=].

<table class="classinfo data" align="left" id="classAccessGrantSubject">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr>
      <th colspan=3>[AccessGrantSubject](interop.ttl#AccessGrant)</th>
    </tr>
    <tr>
      <th>Property</th>
      <th>Range</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>accessByAgent</td>
      <td>[Agent](#classAgent)</td>
      <td>[=Agent=] being granted access</td>
    </tr>
    <tr>
      <td>accessByApplication</td>
      <td>[Application](#classApplication)</td>
      <td>[=Application=] being granted access</td>
    </tr>
  </tbody>
</table>

The [AccessGrantSubjectShape](#shexAccessGrantSubject) is used to validate
an instance of the [AccessGrantSubject](#classAccessGrantSubject) class.

<pre highlight="turtle" id="shexAccessGrantSubject">
<#AccessGrantSubjectShape> {
  a [ interop:AccessGrantSubject ] ;
  interop:accessGrantSubjectAgent IRI? ;
  interop:accessGrantSubjectApplication IRI?
}
</pre>

### Data Grant ### {#datamodel-data-grant}

A <dfn>Data Grant</dfn> records a decision made by a
given [=Agent=] based upon [=Compiled Accesses=] presented to them
for a given [=Data Registration=].

<table class="classinfo data" align="left" id="classDataGrant">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr>
      <th colspan=3>
        [DataGrant](interop.ttl#DataGrant)
      </th>
    </tr>
    <tr>
      <th>Property</th>
      <th>Range</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>hasRegistration</td>
      <td>[DataRegistration](#classDataRegistration)</td>
      <td>[=Data Registration=] the [=Data Grant=] applies to</td>
    </tr>
    <tr>
      <td>registeredShapeTree</td>
      <td>st:ShapeTree</td>
      <td>The [=shape tree=] registered at the target [=Data Registration=]</td>
    </tr>
    <tr>
      <td>satisfiesCompiledAccess</td>
      <td>[CompiledAccess](#classCompiledAccess)</td>
      <td>Links to a [=Compiled Access=] satisfied by the [=Data Grant=]</td>
    </tr>
    <tr>
      <td>accessMode</td>
      <td>acl:Read, acl:Write, acl:Control, acl:Append</td>
      <td>Union of access modes from [=Compiled Accesses=] linked by
      satisfiesCompiledAccess</td>
    </tr>
    <tr>
      <td>scopeOfDataGrant</td>
      <td> interop:AllInstances, interop:InheritInstances,
      interop:SelectedInstances, interop:NoAccess</td>
      <td>Identifies the access scope of the [=Data Grant=]
        <ul>
          <li>interop:AllInstances - Scope includes
              access to all [=Data Instances=] of the associated
              [=Data Registration=]</li>
          <li>interop:InheritInstances - Scope includes
              access to [=Data Instances=] inherited by
              instances selected in the parent [=Data Grant=], 
              identified by linked [=Data Inheritances=]</li>
          <li>interop:SelectedInstances - Scope includes
              access only to those [=Data Instances=] specifically
              selected by the [=Agent=]</li>
          <li>interop:NoAccess - No access is granted</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>hasDataInheritance</td>
      <td>[DataInheritance](#classDataInheritance)</td>
      <td>Links to a [=Data Inheritance=] which identifies another [=Data Grant=]
      that access is inherited from</td>
    </tr>
    <tr>
      <td>hasDataInstance</td>
      <td>Instance of registeredShapeTree</td>
      <td>Links to a [=Data Instance=] of registeredShapeTree.</td>
    </tr>
  </tbody>
</table>

The [DataGrantShape](#shexDataGrant) is used to
validate an instance of the [DataGrant](#classDataGrant)
class.

<pre highlight="turtle" id="shexDataGrant">
<#DataGrantShape> {
  a [ interop:DataGrant ] ;
  interop:hasRegistration IRI ;
  interop:registeredShapeTree IRI ;
  interop:satisfiesCompiledAccess @CompiledAccessShape+ ;
  interop:accessMode @<#:AccessModes>+ ;
  interop:scopeOfDataGrant @<#:DataGrantScopes>+ ;
  interop:hasDataInheritance @DataInheritanceShape* ;
  interop:hasDataInstance IRI* 
}

<#DataGrantScopes> [
  interop:SelectedInstances
  interop:AllInstances
  interop:InheritInstances
  interop:NoAccess
]
</pre>

### Data Inheritance ### {#datamodel-data-inheritance}

A <dfn>Data Inheritance</dfn> associates a given [=Data Grant=],
[=Remote Data Grant=], or [=Data Receipt=] with
another from whom it inherited access. It records the
[=shape tree=] reference through which that inheritance was determined.

<table class="classinfo data" align="left" id="classDataInheritance">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr>
      <th colspan=3>
        [DataInheritance](interop.ttl#DataInheritance)        
      </th>
    </tr>
    <tr>
      <th>Property</th>
      <th>Range</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>inheritsFrom</td>
      <td>[DataGrant](#classDataGrant),
      [RemoteDataGrant](#classRemoteDataGrant),
      [DataReceipt](#classDataReceipt)</td>
      <td>Item that was inherited from</td>
    </tr>
    <tr>
      <td>st:traverseViaShapePath</td>
      <td>[ShapePath](#)</td>
      <td>The shape path linking a parent item to inherited instances</td>
    </tr>
  </tbody>
</table>

The [DataInheritanceShape](#shexDataInheritance) is used to validate an
instance of the [DataInheritance](#classDataInheritance) class.

<pre highlight="turtle" id="shexDataInheritance">
<#DataInheritanceShape> {
  a [ interop:DataInheritance ] ;
  interop:inheritsFrom [ @<#:DataGrantShape> @<#:DataReceiptShape> @<#:RemoteDataGrantShape> ];
  st:traverseViaShapePath xsd:string
}
</pre>

### Remote Data Grant ### {#datamodel-remote-data-grant}

A <dfn>Remote Data Grant</dfn> represents the access granted to an 
[=Access Grant Subject=] to data in a [=Remote Data Registry=] related
to a specific type of [=shape tree=].

<table class="classinfo data" align="left" id="classRemoteDataGrant">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr>
      <th colspan=3>
        [RemoteDataGrant](interop.ttl#RemoteDataGrant)        
      </th>
    </tr>
    <tr>
      <th>Property</th>
      <th>Range</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>registeredShapeTree</td>
      <td>st:ShapeTree</td>
      <td>The [=shape tree=] associated with the [=Remote Data Grant=]</td>
    </tr>
    <tr>
      <td>satisfiesCompiledAccess</td>
      <td>[CompiledAccess](#classCompiledAccess)</td>
      <td>Links to a [=Compiled Access=] satisfied by the [=Remote Data Grant=]</td>
    </tr>
    <tr>
      <td>scopeOfRemoteDataGrant</td>
      <td>interop:AllRemote, interop:SelectedRemote, interop:NoAccess</td>
      <td>Identifies the access scope of the [=Remote Data Grant=]
        <ul>
          <li>interop:AllRemote - Scope includes
              access to all [=Remote Data Registrations=] in a 
              given [=Remote Data Registration Set=], linked via
              `interop:hasRemoteDataRegistrationSet`</li>
          <li>interop:SelectedRemote - Scope includes
              access to selected [=Remote Data Registrations=] linked via
              `interop:hasRemoteDataRegistration`</li>
          <li>interop:NoAccess - No access is granted</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>accessMode</td>
      <td>acl:Read, acl:Write, acl:Control, acl:Append</td>
      <td>Mode of access for the grant</td>
    </tr>
    <tr>
      <td>hasRemoteDataRegistrationSet</td>
      <td>[RemoteDataRegistrationSet](#classRemoteDataRegistrationSet)</td>
      <td>The [=Remote Data Registration Set=] that access is being granted for</td>
    </tr>
    <tr>
      <td>hasRemoteDataRegistrationGrant</td>
      <td>[RemoteDataRegistrationGrant](#classRemoteDataRegistrationGrant)</td>
      <td>A grant specific to a given [=Remote Data Registration=]</td>
    </tr>
  </tbody>
</table>

The [RemoteDataGrantShape](#shexRemoteDataGrant) is used to validate an
instance of the [RemoteDataGrant](#classRemoteDataGrant) class.

<pre highlight="turtle" id="shexRemoteDataGrant">
<#RemoteDataGrantShape> {
  a [ interop:RemoteDataGrant ] ;
  interop:registeredShapeTree IRI ;
  interop:satisfiesCompiledAccess @<#:CompiledAccessShape>+ ;
  interop:accessMode @<#:AccessModes>+ ;
  interop:scopeOfRemoteDataGrant @<#:RemoteDataGrantScopes>+ ;
  ( interop:hasRemoteDataRegistrationSet IRI |
    interop:hasRemoteDataRegistrationGrant @<#:RemoteDataRegistrationGrantShape>+ ) 
}

# Remote Data Grant Scopes
<#RemoteDataGrantScopes> [
  interop:AllRemote
  interop:SelectedRemote
  interop:NoAccess
]
</pre>

### Remote Data Registration Grant ### {#datamodel-remote-data-registration-grant}

A <dfn>Remote Data Registration Grant</dfn> represents the access granted to an 
[=Access Grant Subject] to a specific [=Remote Data Registration=] in a 
[=Remote Data Registry=], related to a specific type of [=shape tree=].

<table class="classinfo data" align="left" id="classRemoteDataRegistrationGrant">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr>
      <th colspan=3>
        [RemoteDataRegistrationGrant](interop.ttl#RemoteDataRegistrationGrant)        
      </th>
    </tr>
    <tr>
      <th>Property</th>
      <th>Range</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>registeredShapeTree</td>
      <td>st:ShapeTree</td>
      <td>The [=shape tree=] associated with the [=Remote Data Registration Grant=]</td>
    </tr>
    <tr>
      <td>scopeOfRemoteDataRegistrationGrant</td>
      <td> interop:AllInstances, interop:InheritInstances,
      interop:SelectedInstances, interop:NoAccess</td>
      <td>Identifies the access scope of the [=Remote Data Registration Grant=]
        <ul>
          <li>interop:AllInstances - Scope includes
              access to all [=Remote Data Instances=] of the associated
              [=Remote Data Registration=]</li>
          <li>interop:InheritInstances - Scope includes
              access to [=Remote Data Instances=] inherited by
              instances selected in the parent [=Remote Data Grant=],
              identified by the linked [=Data Inheritances=] in the
              associated [=Data Grant=]</li>
          <li>interop:SelectedInstances - Scope includes
              access only to those [=Remote Data Instances=] specifically
              selected by the [=Agent=]</li>
          <li>interop:NoAccess - No access is granted</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>accessMode</td>
      <td>acl:Read, acl:Write, acl:Control, acl:Append</td>
      <td>Mode of access for the grant</td>
    </tr>
    <tr>
      <td>hasRemoteDataRegistration</td>
      <td>[RemoteDataRegistration](#classRemoteDataRegistration)</td>
      <td>The [=Remote Data Registration=] that access is being granted for</td>
    </tr>
    <tr>
      <td>hasDataInheritance</td>
      <td>[DataInheritance](#classDataInheritance)</td>
      <td>Links to a [=Data Inheritance=] which identifies another 
      [=Remote Data Registration Grant=] that access is inherited from</td>
    </tr>
    <tr>
      <td>hasRemoteDataInstance</td>
      <td>[RemoteDataInstance](#classRemoteDataInstance)</td>
      <td>A [=Remote Data Instance=] that was specifically granted access</td>
    </tr>
  </tbody>
</table>

The [RemoteDataRegistrationGrantShape](#shexRemoteDataRegistrationGrant) is 
used to validate an instance of the 
[RemoteDataRegistrationGrant](#classRemoteDataRegistrationGrant) class.

<pre highlight="turtle" id="shexRemoteDataRegistrationGrant">
  a [ interop:RemoteDataRegistrationGrant ] ;  
  interop:registeredShapeTree IRI ;
  interop:hasRemoteDataRegistration IRI ;
  interop:accessMode @<#:AccessModes>+ ;
  interop:scopeOfRemoteDataRegistrationGrant @<#:DataGrantScopes>+ ;
  interop:hasDataInheritance @<#:DataInheritanceShape>* ;
  interop:hasRemoteDataInstance IRI*
</pre>

### Trusted Grant ### {#datamodel-trusted-grant}

A <dfn>Trusted Grant</dfn> records a decision made by a
given [=Agent=] to trust another with elevated access to [=registries=], 
[=registry sets=], or the [=identity=]
of the [=Agent=] themselves.

A <dfn>Trusted Agent</dfn> is an [=Agent=] that been granted elevated 
access through a [=Trusted Grant=].

<table class="classinfo data" align="left" id="classTrustedGrant">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr>
      <th colspan=3>
        [TrustedGrant](interop.ttl#TrustedGrant)
      </th>
    </tr>
    <tr>
      <th>Property</th>
      <th>Range</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>trustedWith</td>
      <td>[=Agent=], [=Registry Set=], [=Registry=]</td>
      <td>Identifies the scope of the [=Trusted Grant=]
        <ul>
          <li>[=Agent=] - Access to the profile document of the [=Agent=]</li>
          <li>[=Registry Set=] - Access to the specified [=Registry Set=],
          as well as all [=Registries=] linked to it</li>
          <li>[=Registry=] - Access to the specified [=Registry=],
          as well as all [=Registrations=] linked to it</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>trustedWithType</td>
      <td><ul>
        <li>`interop:Agent`</li>
        <li>`interop:ApplicationRegistrySet`</li>
        <li>`interop:DataRegistrySet`</li>
        <li>`interop:AccessGrantRegistrySet`</li>
        <li>`interop:AccessReceiptRegistrySet`</li>
        <li>`interop:RemoteDataRegistrySet`</li>
        <li>`interop:ApplicationRegistry`</li>
        <li>`interop:DataRegistry`</li>
        <li>`interop:AccessGrantRegistry`</li>
        <li>`interop:AccessReceiptRegistry`</li>
        <li>`interop:RemoteDataRegistry`</li>
      </ul></td>
      <td>Specific type of instance linked via `trustedWith`</td>
    </tr>
    <tr>
      <td>satisfiesCompiledTrustedAccess</td>
      <td>[CompiledTrustedAccess](#)</td>
      <td>Links to a [=Compiled Trusted Access=] satisfied by the [=Trusted Grant=]</td>
    </tr>
    <tr>
      <td>accessMode</td>
      <td>acl:Read, acl:Write, acl:Control, acl:Append</td>
      <td>Mode of access being granted to the instance linked via `trustedWith`</td>
    </tr>
  </tbody>
</table>

The [TrustedGrantShape](#shexTrustedGrant) is used to
validate an instance of the [TrustedGrant](#classTrustedGrant)
class.

<pre highlight="turtle" id="shexTrustedGrant">
<#TrustedGrantShape> {
  a [ interop:TrustedGrant ] ;
  interop:trustedWith IRI ;
  interop:trustedWithType [ interop:Agent interop:RegistrySet interop:Registry ] ;
  interop:satisfiesCompiledTrustedAccess @<#:CompiledTrustedAccessShape>+ ;
  interop:accessMode [ acl:Read acl:Write acl:Append acl:Control ]+ 
}
</pre>

### Access Invitation ### {#datamodel-access-invitation}

An <dfn>Access Invitation</dfn> is a subclass of [=Access Grant=] used when
an [=Agent=] wishes to grant access to another [=Agent=] whose
decentralized [=identity=] is unknown to them, or may not exist yet, so they
must be first invited through another channel (such as phone or email).

Like an [=Access Grant=], an [=Access Invitation=] links to access
criteria detailed in one or more [=Compiled Access Groups=], with
associated [=Data Grants=] or [=Trusted Grants=] indicating the 
intended access to be granted.

However, instead of linking to an [=Access Grant Subject=], an
[=Access Invitation=] links to one or more [=Access Invitation Channels=].

Each channel represents a mechanism through which the invitation can
be delivered and validated. The mechanism is designed so that multiple
channels may be validated before an invitation is confirmed and
converted to an [=Access Grant=].

<table class="classinfo data" align="left" id="classAccessInvitation">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr>
      <th colspan=3>
        [AccessInvitation](interop.ttl#AccessInvitation)
        a rdfs:subClassOf [AccessGrant](#classAccessGrant)
      </th>
    </tr>
    <tr>
      <th>Property</th>
      <th>Range</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>registeredBy</td>
      <td>[Agent](#classAgent)</td>
      <td>[=Agent=] that registered the [=Access Invitation=]</td>
    </tr>
    <tr>
      <td>registeredWith</td>
      <td>[Application](#classApplication)</td>
      <td>[=Application=] used to create the [=Access Invitation=]</td>
    </tr>
    <tr>
      <td>registeredAt</td>
      <td>xsd:dateTime</td>
      <td>Date and time the [=Access Invitation=] was created</td>
    </tr>
    <tr>
      <td>updatedAt</td>
      <td>xsd:dateTime</td>
      <td>Date and time the [=Access Invitation=] was updated</td>
    </tr>
    <tr>
      <td>expiresAt</td>
      <td>xsd:dateTime</td>
      <td>Date and time the [=Access Invitation=] expires</td>
    </tr>
    <tr>
      <td>hasAccessInvitationChannel</td>
      <td>[AccessInvitationChannel](#classAccessInvitationChannel)</td>
      <td>Links to an [=Access Invitation Channel=]</td>
    </tr>
    <tr>
      <td>hasCompiledAccessGroup</td>
      <td>[CompiledAccessGroup](#classCompiledAccessGroup)</td>
      <td>Links to a [=Compiled Access Group=] associated with the
      [=Access Invitation=].</td>
    </tr>
    <tr>
      <td>hasDataGrant</td>
      <td>[DataGrant](#classDataGrant)</td>
      <td>Links to a [=Data Grant=] associated with the
      [=Access Invitation=].</td>
    </tr>
    <tr>
      <td>hasTrustedGrant</td>
      <td>[TrustedGrant](#classTrustedGrant)</td>
      <td>Links to a [=Trusted Grant=] associated with the 
      [=Access Invitation=].</td>
    </tr>
    <tr>
      <td>hasRemoteDataGrant</td>
      <td>[RemoteDataGrant](#classRemoteDataGrant)</td>
      <td>Links to a [=Remote Data Grant=] associated with the [=Access Invitation=].</td>
    </tr>
  </tbody>
</table>

The [AccessInvitationShape](#shexAccessInvitation) is used to validate an
instance of the [AccessInvitation](#classAccessInvitation) class.

<pre highlight="turtle" id="shexAccessInvitation">
<#AccessInvitationShape> {
  a [ interop:AccessInvitation ] ;
  interop:registeredBy IRI ;
  interop:registeredWith IRI? ;
  interop:registeredAt xsd:dateTime ;
  interop:updatedAt xsd:dateTime ;
  interop:expiresAt xsd:dateTime? ;
  interop:hasCompiledAccessGroup @<#:CompiledAccessGroupShape>+ ;
  ( interop:hasDataGrant @<#:DataGrantShape>+ |
  interop:hasTrustedGrant @<#:TrustedGrantShape>+ |
  interop:hasRemoteDataGrant @<#:RemoteDataGrantShape>+ ) ;
  interop:hasAccessInvitationChannel @<#:AccessInvitationChannelShape>+
}
</pre>

The [AccessInvitationTree](interop.tree#AccessInvitationTree) is assigned
to a resource via the [AccessGrantRegistryTree](#treeAccessGrantRegistry), and ensures
that the assigned resource will validate against the
[AccessInvitationShape](#shexAccessInvitation).

<pre highlight="turtle" id="treeAccessInvitation">
<#AccessInvitationTree>
  a st:ShapeTree;
  st:expectsType st:ShapeTreeResource ;
  st:validatedBy &lt;interops#AccessInvitationShape&gt; ;
  st:matchesUriTemplate "{id}" .
</pre>

### Access Invitation Channel ### {#datamodel-access-invitation-channel}

An <dfn>Access Invitation Channel</dfn> represents a mechanism through
which an [=Access Invitation=] can be delivered and validated.

<table class="classinfo data" align="left" id="classAccessInvitationChannel">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr>
      <th colspan=3>
        [AccessInvitationChannel](interop.ttl#AccessInvitationChannel)
      </th>
    </tr>
    <tr>
      <th>Property</th>
      <th>Range</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>rdf:type</td>
      <td>interop:PhoneInvitationChannel,
      interop:EmailInvitationChannel,
      interop:SMSInvitationChannel,
      interop:OfflineInvitationChannel,
      interop:LDNInvitationChannel</td>
      <td>Each channel is represented by a subClassOf
      AccessInvitationChannel</td>
    </tr>
    <tr>
      <td>channelTarget</td>
      <td>xsd:string</td>
      <td>Target used when validating the channel</td>
    </tr>
    <tr>
      <td>channelCode</td>
      <td>xsd:string</td>
      <td>Code used for channel validation</td>
    </tr>
    <tr>
      <td>isValidated</td>
      <td>xsd:boolean</td>
      <td>Indicates whether the channel has been validated</td>
    </tr>
    <tr>
      <td>remainingAttempts</td>
      <td>xsd:integer</td>
      <td>Number of allowed validation attempts remaining</td>
    </tr>
  </tbody>
</table>

The [AccessInvitationChannelShape](#shexAccessInvitationChannel) is used to
validate an instance of the
[AccessInvitationChannel](#classAccessInvitation) class.

<pre highlight="turtle" id="shexAccessInvitationChannel">
<#AccessInvitationChannelShape> {
   a @<#ChannelTypes> ;
   interop:channelTarget xsd:string ;
   interop:channelCode xsd:string ;
   interop:isValidated xsd:boolean ;
   interop:remainingAttempts xsd:integer
}

<#ChannelTypes> [
  :PhoneInvitationChannel   # Telephone
  :EmailInvitationChannel   # E-mail
  :SMSInvitationChannel     # SMS (Simple Messaging Service)
  :OfflineInvitationChannel # Other communication, e.g. verbal, shared note
  :LDNInvitationChannel     # Linked Data Notification
]
</pre>

## Resource Hierarchy ## {#grants-hierarchy}

<table class="data tree" align="left">
  <col>
  <col>
  <col>
  <col>
  <thead>
    <tr>
      <th>Resource</th>
      <th>Class</th>
      <th>Shape</th>
      <th>Shape Tree</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`/profile/`</td>
      <td>-</td>
      <td>-</td>
      <td>[ProfileTree](#treeAgent)</td>
    </tr>
    <tr>
      <td>`-- grant#set`</td>
      <td>[AccessGrantRegistrySet](#classAccessGrantRegistrySet)</td>
      <td>[AccessGrantRegistrySetShape](#shexAccessGrantRegistrySet)</td>
      <td>[AccessGrantRegistrySetTree](#treeAccessGrantRegistrySet)</td>
    </tr>
    <tr>
      <td>`/grants/#registry`</td>
      <td>[AccessGrantRegistry](#classAccessGrantRegistry)</td>
      <td>[AccessGrantRegistryShape](#shexAccessGrantRegistry)</td>
      <td>[AccessGrantRegistryTree](#treeAccessGrantRegistry)</td>
    </tr>
    <tr>
      <td>`-- c482f931...630e5ab0#grant`</td>
      <td>[AccessGrant](#classAccessGrant)</td>
      <td>[AccessGrantShape](#shexAccessGrant)</td>
      <td>[AccessGrantTree](#treeAccessGrant)</td>
    </tr>
    <tr>
      <td>`-- e0983a7e...88c387ea#grant`</td>
      <td>[AccessGrant](#classAccessGrant)</td>
      <td>[AccessGrantShape](#shexAccessGrant)</td>
      <td>[AccessGrantTree](#treeAccessGrant)</td>
    </tr>
    <tr>
      <td>`-- eddf13d6...7f4962c5#grant`</td>
      <td>[AccessGrant](#classAccessGrant)</td>
      <td>[AccessGrantShape](#shexAccessGrant)</td>
      <td>[AccessGrantTree](#treeAccessGrant)</td>
    </tr>
    <tr>
      <td>`-- a990c1b9...c041eb74#grant`</td>
      <td>[AccessGrant](#classAccessGrant)</td>
      <td>[AccessGrantShape](#shexAccessGrant)</td>
      <td>[AccessGrantTree](#treeAccessGrant)</td>
    </tr>
    <tr>
      <td>`-- 265ef957...6689aee7#grant`</td>
      <td>[AccessGrant](#classAccessGrant)</td>
      <td>[AccessGrantShape](#shexAccessGrant)</td>
      <td>[AccessGrantTree](#treeAccessGrant)</td>
    </tr>
  </tbody>
</table>

The [=Access Grant Registry Set=] and the [=Access Grant Registry=] MAY or MAY NOT
be on the same [=pod=].

[=Access Grant Registry Set=] and [=Access Grant Registry=] resources MAY use any
resource or subject names.

[=Access Grants=] MUST use \[UUIDs](https://www.ietf.org/rfc/rfc4122.txt)
for resource names.

## Operations ## {#grants-operations}

* [[#grants-initializegrant]] - Initializes a new [=Access Grant=] for a given
    [=Access Grant Subject=] or an [=Access Invitation=] for one or more
    [=Access Invitation Channels=] with one or more [=Access Need Groups=]
    * [[#grants-initializedatagrant]] - Initialize a [=Data Grant=] as part
        of [=Access Grant=] initialization
    * [[#grants-initializeremotegrant]] - Initialize a [=Remote Data Grant=] as
        part of [=Access Grant=] initialization
    * [[#grants-initializetrustedgrant]] - Initialize a [=Trusted Grant=] as part
        of [=Access Grant=] initialization
* [[#grants-loadgrant]] - Load an existing [=Access Grant=]
    from an [=Access Grant Registry=]
* [[#grants-loadinvitation]] - Load an existing [=Access Invitation=]
    from an [=Access Grant Registry=]
* [[#grants-recordgrant]] - Store a new or updated [=Access Grant=]
    in an [=Access Grant Registry=]
* [[#grants-validategrant]] - Validate a new or updated [=Access Grant=]
* [[#grants-recordinvitation]] - Store a new or updated [=Access Invitation=]
    in an [=Access Grant Registry=]
* [[#grants-applyperms]] - Apply permissions to [=acl resources=] based
    on [=Access Grant=] decisions.
    * [[#grants-applydataperms]] - Apply permissions for a given [=Data Grant=]
    * [[#grants-applyremoteperms]] - Apply permissions for a 
        given [=Remote Data Grant=]
    * [[#grants-applyremoteregperms]] - Apply permissions for a 
        given [=Remote Data Registration Grant=]
    * [[#grants-applytrustedperms]] - Apply permissions for a 
        given [=Trusted Grant=]
    * [[#grants-applyresourceperms]] - Apply permissions on a given resource for 
        a given [=Access Grant Subject=]
    * [[#grants-applyconditionalperms]] - Apply permissions on a given resource
        for a given [=Access Grant Subject=], condiioned upon a graph relationship
    * [[#grants-removeresourceperms]] - Remove permissions on a given resource
        for a given [=Access Grant Subject=]
* [[#grants-present-access]] - A non-normative operation meant to instruct
    a developer in how to load, initialize, and manage an [=Access Grant=].    
* [[#grants-present-invitation]] - A non-normative operation meant to instruct
    a developer in how to load, initialize, and manage an [=Access Invitation=].

### Initialize Grant ### {#grants-initializegrant}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
        Initialize an [=Access Grant=] or [=Access Invitation=] by processing
        the input [=Access Need Groups=] into [=Compiled Access Groups=], 
        then initializing [=Data Grants=], [=Remote Data Grants=], 
        or [=Trusted Grants=] with no access (yet) for the 
        corresponding [=Compiled Accesses=] in each group.
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`SUBJECT`</td>
      <td>The [=Access Grant Subject=] that the [=Access Grant=] is related to</td>
    </tr>
    <tr>
      <td>`ICHANNELS`</td>
      <td>A set of [=Access Invitation Channels=]</td>
    </tr>
    <tr>
      <td>`GROUPS`</td>
      <td>[=Access Need Groups=] to associate with the [=Access Grant=]</td>
    </tr>
    <tr>
      <td>`LANG`</td>
      <td>The [=Agent's=] preferred language</td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>[=Access Grant=], [=Access Invitation=]</td>
      <td>Newly initialized [=Access Grant=] or [=Access Invitation=]</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. <em class="rfc2119">MUST</em> return a status code of 400 if both
    `SUBJECT` and `ICHANNELS` are provided
1. If `SUBJECT` is provided
    1. Let `NEW` be a newly initialized [=Access Grant=]
    1. Let `NEW hasAccessGrantSubject` be `SUBJECT`
1. If `ICHANNELS` is provided
    1. Let `NEW` be a newly initialized [=Access Invitation=]
    1. For each [=Access Invitation Channel=] `ICHANNEL` in `ICHANNELS`
        1. Let `ICHANNEL` be linked to `NEW` via `NEW hasAccessInvitationChannel`
1. For each [=Access Need Group=] `GROUP` in `GROUPS`
    1. Let `CAGROUP` be the [=Compiled Access Group=] returned from
        [[#compile-group]] with inputs `GROUP`, `LANG`
    1. Link `CAGROUP` to `NEW` via `NEW hasCompiledAccessGroup`
1. Let `CAGROUPS` be all [=Compiled Access Groups=] linked to `NEW`
    via `hasCompiledAccessGroup`
1. Let `DATAGRANTS` be an empty set of [=Data Grants=]
1. Let `TRUSTEDGRANTS` be an empty set of [=Trusted Grants=]
1. Let `REMOTEGRANTS` be an empty set of [=Remote Data Grants=] 
1. For each [=Compiled Access Group=] `CAGROUP` in `CAGROUPS`
    1. For each [=Compiled Access=] `CACCESS` in `CAGROUP`
        1. Call [[#grants-initializedatagrant]] with inputs: `CACCESS`, `DATAGRANTS`
        1. Call [[#grants-initializeremotegrant]] with inputs: `CACCESS`, `REMOTEGRANTS`
    1. For each [=Compiled Trusted Access=] `CTACCESS` in `CAGROUP`
        1. Call [[#grants-initializetrustedgrant]] with inputs: `CTACCESS`, `TRUSTEDGRANTS`
1. Return `NEW`

</div>

### Initialize Data Grant ### {#grants-initializedatagrant}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
        Initialize a [=Data Grant=] and link it to the provided 
        [=Compiled Access=] `CACCESS`.
        This operation looks for a [=Data Grant=] related to the 
        [=shape tree=] in the working `DATAGRANTS` set to update. It will 
        create one if it doesn't find one to update, and then add it 
        to `DATAGRANTS`.
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`CACCESS`</td>
      <td>A [=Compiled Access=]</td>
    </tr>
    <tr>
      <td>`DATAGRANTS`</td>
      <td>A working set of [=Data Grants=] passed in by reference</td>
    </tr>    
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>[=Data Grant=]</td>
      <td>Initialized [=Data Grant=] corresponding to `CACCESS`</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Let `MATCHING` be a [=Data Grant=] in `DATAGRANTS` where
    `CACCESS registeredShapeTree` == `MATCHING registeredShapeTree`
1. If `MATCHING` let `CACCESS hasDataGrant` be `MATCHING`
1. If `MATCHING` is missing
    1. Let `NEWDATAGRANT` be a newly initialized [=Data Grant=]
    1. Let `NEWDATAGRANT registeredShapeTree` be `CACCESS registeredShapeTree`
    1. Let `NEWDATAGRANT hasRegistration` be a [=Data Registration=] `DR`
        where `DR registeredShapeTree` == `NEWDATAGRANT registeredShapeTree`
    1. Let `NEWDATAGRANT scopeOfDataGrant` be `interop:NoAccess`
    1. Let `CACCESS hasDataGrant` be `NEWDATAGRANT`
    1. Add `CACCESS hasDataGrant` to `DATAGRANTS`
1. Let `DATAGRANT` be `CACCESS hasDataGrant`
1. Let `DATAGRANT satisfiesCompiledAccess` include `CACCESS`
1. Let `DATAGRANT accessmode`s include `CACCESS accessmode`s
1. Return `DATAGRANT`

</div>

### Initialize Remote Data Grant ### {#grants-initializeremotegrant}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
        Initialize a [=Remote Data Grant=] and link it to the provided 
        [=Compiled Access=] `CACCESS`.
        This operation looks for a [=Remote Data Grant=] related to the 
        [=shape tree=] in the working `REMOTEGRANTS` set to update. It will 
        create one if it doesn't find one to update, and then add it 
        to `REMOTEGRANTS`.
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`CACCESS`</td>
      <td>A [=Compiled Access=]</td>
    </tr>
    <tr>
      <td>`REMOTEGRANTS`</td>
      <td>A working set of [=Remote Data Grants=] passed in by reference</td>
    </tr>    
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>[=Remote Data Grant=]</td>
      <td>Initialized [=Remote Data Grant=] corresponding to `CACCESS`</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Let `MATCHING` be a [=Remote Data Grant=] in `REMOTEGRANTS` where
    `CACCESS registeredShapeTree` == `MATCHING registeredShapeTree`
1. If `MATCHING` let `CACCESS hasRemoteDataGrant` be `MATCHING`
1. If `MATCHING` is missing
    1. Let `NEWRDGRANT` be a newly initialized [=Remote Data Grant=]
    1. Let `NEWRDGRANT registeredShapeTree` be `CACCESS registeredShapeTree`
    1. Let `NEWRDGRANT scopeOfDataGrant` be `interop:NoAccess`
    1. Let `CACCESS hasRemoteDataGrant` be `NEWRDGRANT`
    1. Add `CACCESS hasRemoteDataGrant` to `REMOTEGRANTS`
1. Let `RDGRANT` be `CACCESS hasRemoteDataGrant`
1. Let `RDGRANT satisfiesCompiledAccess` include `CACCESS`
1. Let `RDGRANT accessmode`s include `CACCESS accessmode`s
1. Return `RDGRANT`

</div>

### Initialize Trusted Grant ### {#grants-initializetrustedgrant}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
        Initialize a [=Trusted Grant=] and link it to the provided 
        [=Compiled Trusted Access=] `CTACCESS`.
        This operation looks for a [=Trusted Grant=] related to 
        `CTACCESS trustedWith` in the working `TRUSTEDGRANTS` set to update. 
        It will create one if it doesn't find one to update, and then add it 
        to `TRUSTEDGRANTS`.
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`CTACCESS`</td>
      <td>A [=Compiled Trusted Access=]</td>
    </tr>
    <tr>
      <td>`TRUSTEDGRANTS`</td>
      <td>A working set of [=Trusted Grants=] passed in by reference</td>
    </tr>    
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>[=Trusted Grant=]</td>
      <td>Initialized [=Trusted Grant=] corresponding to `CTACCESS`</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Let `MATCHING` be a [=Trusted Grant=] in `TRUSTEDGRANTS` where
    `CTACCESS trustedWith` == `MATCHING trustedWith`
1. If `MATCHING` let `CTACCESS hasTrustedGrant` be `MATCHING`
1. If `MATCHING` is missing
    1. Let `NEWTRUSTEDGRANT` be a newly initialized [=Trusted Grant=]
    1. Let `NEWTRUSTEDGRANT trustedWith` be `CTACCESS trustedWith`
    1. Let `NEWTRUSTEDGRANT trustedWithType` be `CTACCESS trustedWithType`
    1. Let `CTACCESS hasTrustedGrant` be `NEWTRUSTEDGRANT`
    1. Add `CTACCESS hasTrustedGrant` to `TRUSTEDGRANTS`
1. Let `TRUSTEDGRANT` be `CTACCESS hasTrustedGrant`
1. Let `TRUSTEDGRANT satisfiesCompiledTrustedAccess` include `CTACCESS`
1. Let `TRUSTEDGRANT accessmode`s include `CTACCESS accessmode`s
1. Return `TRUSTEDGRANT`

</div>

### Load Grant ### {#grants-loadgrant}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
      This operation will load an [=Access Grant=] from a given 
      [=Access Grant Registry=]
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`SUBJECT`</td>
      <td>An [=Access Grant Subject=] to lookup</td>
    </tr>
    <tr>
      <td>`REGISTRY`</td>
      <td>An [=Access Grant Registry=] to search</td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>[=Access Grant=]</td>
      <td>Corresponding to `SUBJECT`</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. For each [=Access Grant=] `GRANT` included in `REGISTRY hasRegistration`
    1. return `GRANT` if `GRANT hasAccessGrantSubject` == `SUBJECT`

</div>

### Load Invitation ### {#grants-loadinvitation}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
      This operation will load an [=Access Invitation=] from a 
      given [=Access Grant Registry=]
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`TARGET`</td>
      <td>An `interop:ChannelTarget` to match</td>
    </tr>
    <tr>
      <td>`CODE`</td>
      <td>An optional `interop:channelCode` to match</td>
    </tr>
    <tr>
      <td>`REGISTRY`</td>
      <td>An [=Access Grant Registry=] to search</td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>[=Access Invitations=]</td>
      <td>Matching `TARGET` and (if provided) `CODE`</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Let `INVITATIONS` be an empty set of [=Access Invitations=]
1. For each [=Access Invitation=] `INVITATION` linked via `REGISTRY hasRegistration`
    1. For each [=Access Invitation Channel=] `ICHANNEL` linked via
        `INVITATION hasAccessInvitationChannel`
        1. Next if `ICHANNEL channelTarget` != `TARGET`
        1. Next if `CODE` is not empty and `ICHANNEL channelCode` != `CODE`
        1. Add `INVITATION` to `INVITATIONS`
1. Return `INVITATIONS`

</div>

### Validate Grant ### {#grants-validategrant}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
      This operation is used to validate an [=Access Grant=]
      or [=Access Invitation=] before it is stored in an 
      [=Access Grant Registry=].
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`GRANT`</td>
      <td>An [=Access Grant=] or [=Access Invitation=]</td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>Boolean</td>
      <td>Success or Failure</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. If `GRANT` is an [=Access Invitation=]
    1. Perform a validation of the RDF graph of `GRANT` against
        [interop:AccessInvitationShape](interop.shex#AccessInvitationShape).
        <em class="rfc2119">MUST</em> return a status code of 400 if
        validation fails.
1. If `GRANT` is an [=Access Grant=]
    1. Perform a validation of the RDF graph of `GRANT` against
        [interop:AccessGrantShape](interop.shex#AccessGrantShape).
        <em class="rfc2119">MUST</em> return a status code of 400 if
        validation fails.
1. Let `CAGROUPS` be the [=Compiled Access Groups=] linked to `GRANT`
    via `GRANT hasCompiledAccessGroup`
1. Let `DGRANTS` be the [=Data Grants=] linked to `GRANT`
    via `GRANT hasDataGrant`
1. Let `TGRANTS` be the [=Trusted Grants=] linked to `GRANT` via 
    `GRANT hasTrustedGrant`
1. Let `RDGRANTS` be the [=Remote Data Grants=] linked to `GRANT` via 
    `GRANT hasRemoteDataGrant`
1. For each [=Compiled Access Group=] `CAGROUP` in `CAGROUPS`:
    1. For each [=Compiled Access=] `CACCESS` in `CAGROUP` traversed via
        `CACCESS skos:narrower` or `CACCESS referencesCompiledAccess`:
        1. Let `NDGRANT` be the [=Data Grant=] associated with
            `CACCESS` via `CACCESS hasDataGrant`
            1. Error if `NDGRANT` is missing
            1. Error if `NDGRANT satisfiesCompiledAccess` doesn't link to `CACCESS`
            1. Error if `interop:RegisteredShapeTree` is not the same in `NDGRANT` and `CACCESS`
    1. For each [=Compiled Trusted Access=] `CTACCESS` in `CAGROUP`:
        1. Let `TGRANT` be the [=Trusted Grant=] associated with `CTACCESS`
            via `CTACCESS hasTrustedGrant`
            1. Error if `TGRANT` is missing
            1. Error if `TGRANT satisfiesCompiledTrustedAccess` doesn't link to `CTACCESS`
            1. Error if `TGRANT trustedWith` is not the same as `CTACCESS trustedWith`
            1. Error if `TGRANT trustedWithType` is not the same as `CTACCESS trustedWithType`
            1. Error if `TGRANT trustedWith` is not a `TGRANT trustedWithType` 
1. For each [=Data Grant=] `DGRANT` in `DGRANTS`
    1. Let `CA` be all [=Compiled Accesses=] across `CAGROUPS`
    1. Let `DGCA` be all [=Compiled Accesses=] linked to `DGRANT` via
        `DGRANT satisfiesCompiledAccess`
    1. Let `SCOPE` be `DGRANT scopeOfDataGrant`
    1. Error if `DGCA` is not in `CA`
    1. Error if `DGCA` is empty
    1. Error if `DGRANT` access modes are not an exact union of
        `DGCA accessMode` values when `DGRANT scopeOfDataGrant` is not
        `interop:NoAccess`
    1. If `SCOPE` includes `interop:NoAccess`
        1. Error if `SCOPE` includes any other scopes
    1. If `SCOPE` includes `interop:AllInstances`
        1. Error if `SCOPE` includes any other scopes
    1. If `SCOPE` includes ONLY `interop:InheritInstances`
        1. Let `INHERITANCES` be the [=Data Inheritances=] linked via 
            `DGRANT hasDataInheritance`
        1. Error if `INHERITANCES` is empty
        1. For each  [=Data Inheritances=] `INHERITANCE` in `INHERITANCES`
            1. Let `PDGRANT` be the [=Data Grant=] linked via `INHERITANCE inheritsFrom`
            1. Error if `DGRANT interop:RegisteredShapeTree` does not have a reference
                to `PDGRANT interop:RegisteredShapeTree` via
                `INHERITANCE st:traverseViaShapePath`
    1. If `SCOPE` includes `interop:InheritInstances` AND `interop:SelectedInstances`
        1. Error if `SCOPE` includes any other scopes
    1. If `SCOPE` includes `interop:SelectedInstances`        
        1. Error if `DGRANT interop:hasDataInstance` is missing
1. For each [=Remote Data Grant=] `RDGRANT` in `RDGRANTS`
    1. Let `CA` be all [=Compiled Accesses=] across `CAGROUPS`
    1. Let `RDGCA` be all [=Compiled Accesses=] linked to `RDGRANT` via
        `RDGRANT satisfiesCompiledAccess`
    1. Let `SCOPE` be `RDGRANT scopeOfRemoteDataGrant`
    1. Error if `RDGCA` is not in `CA`
    1. Error if `RDGCA` is empty    
    1. If `SCOPE` is `interop:AllRemote`    
        1. Error if `RDGRANT` access modes are not an exact union of
            `RDGCA accessMode` values
        1. Error if `RDGRANT hasRemoteDataRegistrationSet` is missing
        1. Error if `RDGRANT hasRemoteDataRegistrationGrant` is not missing
    1. If `SCOPE` is `interop:SelectedRemote`
        1. Error if `RDGRANT hasRemoteDataRegistrationSet` is not missing 
        1. Error if `RDGRANT hasRemoteDataRegistrationGrant` is missing
        1. For each [=Remote Data Registration Grant=] `RDRGRANT` linked via
            `RDGRANT hasRemoteDataRegistrationGrant`
            1. Let `RDRSCOPE` be `RDRGRANT scopeOfRemoteDataRegistrationGrant`
            1. Error if `RDRGRANT` access modes are not an exact union of
                `RDGCA accessMode` values
            1. Error if `RDRGRANT hasRemoteDataRegistration` is missing
            1. If `RDRSCOPE` is interop:AllInstances
                1. Error if `RDRGRANT hasDataInstance` is not missing
            1. If `RDRSCOPE` includes interop:SelectedInstances
                1. Error if `RDRGRANT hasDataInstance` is missing
            1. If `RDRSCOPE` includes interop:InheritInstances    
                1. Let `INHERITANCES` be the [=Data Inheritances=] linked via 
                    `RDRGRANT hasDataInheritance`
                1. Error if `INHERITANCES` is empty
                1. For each  [=Data Inheritance=] `INHERITANCE` in `INHERITANCES`
                    1. Let `FROMGRANT` be the [=Remote Data Registration Grant=] 
                        linked via `INHERITANCE inheritsFrom`
                    1. Error if `RDRGRANT interop:registeredShapeTree` does not have a 
                        reference to `FROMGRANT interop:RegisteredShapeTree` via
                        `INHERITANCE st:traverseViaShapePath`
1. For each [=Trusted Grant=] `TGRANT` in `TGRANTS`
    1. Let `CTA` be all [=Compiled Trusted Accesses=] across `CAGROUPS`
    1. Let `TGCTA` be all [=Compiled Trusted Accesses=] linked to `TGRANT` via
        `TGRANT satisfiesCompiledTrustedAccess` 
    1. Error if `TGCTA` is not in `CTA`
    1. Error if `TGCTA` is empty
    1. Error if `TGRANT` access modes are not an exact union of
        `TGCTA accessMode` values

</div>

### Record Grant ### {#grants-recordgrant}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
      This operation stores a new or updated [=Access Grant=] in
      an [=Access Grant Registry=], applies permissions accordingly, and
      calls for an [=Access Receipt=] to be provided.
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`GRANT`</td>
      <td>An [=Access Grant=] to store in `REGISTRY`</td>
    </tr>
    <tr>
      <td>`REGISTRY`</td>
      <td>The [=Access Grant Registry=] to store `GRANT` into</td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>[=Access Grant=]</td>
      <td>Stored in `REGISTRY` with permissions applied and
      [=Access Receipt=] furnished</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Call [[#grants-validategrant]] with inputs: `GRANT`.
    <em class="rfc2119">MUST</em> return a status code of 400 if
    validation fails.
1. Add or Update `GRANT` resource in the `REGISTRY` container, conforming to
    the assigned [interopt:AccessGrantTree](interop.tree#AccessGrantTree).
1. Link `GRANT` to the `REGISTRY` via `REGISTRY hasRegistration` if
        it has not already been added
1. Call [[#grants-applyperms]] with inputs: `GRANT`
1. Call [[#receipts-provide]] with inputs: `GRANT`
1. Return `GRANT`

</div>

Issue: Need to properly factor in multi-pod scenarios. Must identify the
proper access registry to store things in based on the data registration, which
means pods will also need to be registered.

### Record Invitation ### {#grants-recordinvitation}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
      This operation stores a new or updated [=Access Invitation=] in
      an [=Access Grant Registry=].
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`INVITATION`</td>
      <td>An [=Access Invitation=]</td>
    </tr>
    <tr>
      <td>`REGISTRY`</td>
      <td>An [=Access Grant Registry=]</td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>[=Access Invitation=]</td>
      <td>Stored in `REGISTRY`</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Call [[#grants-validategrant]] with inputs: `INVITATION`.
    <em class="rfc2119">MUST</em> return a status code of 400 if
    validation fails.
1. Add or Update `INVITATION` resource in the `REGISTRY` container, conforming to
    the assigned
    [interopt:AccessInvitationTree](interop.tree#AccessInvitationTree)
1. Link `INVITATION` to the `REGISTRY` via `ACCESS hasRegistration` if
        it has not already been added
1. Call [[#grants-deliverinvitation]] with inputs: `INVITATION`
1. Return `INVITATION`

</div>

### Deliver Invitation ### {#grants-deliverinvitation}

Issue: Write standard operation for invitation delivery

### Validate Invitation ### {#grants-validateinvitation}

Issue: Write standard operation for validating an invitation

### Apply Permissions ### {#grants-applyperms}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
      This operation takes a validated [=Access Grant=] `GRANT` 
      associated with a given [=Access Grant Subject=] and
      applies the permissions accordingly based on the [=Data Grants=] and/or 
      [=Trusted Grants=] associated with the [=Access Grant=]. It applies
      to both new and updated [=Access Grants=].
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`GRANT`</td>
      <td>A validated [=Access Grant=]</td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>[=Access Grant=]</td>
      <td>That has had the relevant permissions applied</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Let `DGRANTS` be the [=Data Grants=] linked to `GRANT`
    via `GRANT hasDataGrant`
1. Let `RDGRANTS` be the [=Remote Data Grants=] linked to `GRANT`
    via `GRANT hasRemoteDataGrant`
1. Let `TGRANTS` be the [=Trusted Grants=] linked to `GRANT` via 
    `GRANT hasTrustedGrant`
1. For each [=Data Grant=] `DGRANT` in `DGRANTS`
    1. Call [[#grants-applydataperms]] with inputs: `DGRANT`, `GRANT`
1. For each [=Remote Data Grant=] `RDGRANT` in `RDGRANTS` 
    1. Call [[#grants-applyremoteperms]] with inputs: `RDGRANT`, `GRANT`
1. For each [=Trusted Grant=] `TGRANT` in `TGRANTS`
    1. Call [[#grants-applytrustedperms]] with inputs: `TGRANT`, `GRANT`

</div>

### Apply Data Permissions ### {#grants-applydataperms}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
      This operation applies permissions for a given [=Data Grant=]. It applies
      to both new and updated [=Data Grants=].
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`DGRANT`</td>
      <td>A validated [=Data Grant=]</td>
    </tr>
    <tr>
      <td>`GRANT`</td>
      <td>The validated [=Access Grant=] that `DGRANT` belongs to</td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>[=Data Grant=]</td>
      <td>That has had the relevant permissions applied</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">


1. Let `SUBJECT` be the [=Access Grant Subject=] linked via `GRANT accessGrantSubject`
1. Let `MODES` be the [=access modes=] linked via `DGRANT accessMode`
1. Let `INHERITANCES` be the [=Data Inheritances=] linked via `DGRANT hasDataInheritance`
1. If `DGRANT hasRegistration` is missing
    1. Let `DGRANT hasRegistration` be the [=Data Registration=] returned from
        calling [[#datareg-create]] with inputs: 
        `DGRANT registeredShapeTree`, `DATAREGISTRY`
1. Let `DREG` be the [=Data Registration=] linked via `DGRANT hasRegistration`
1. Let `SCOPE` be `DGRANT scopeOfDataGrant`
1. If `SCOPE` includes `interop:NoAccess`
    1. Call [[#grants-removeresourceperms]] with inputs: `DREG`, `SUBJECT`
1. If `SCOPE` includes `interop:AllInstances`
    1. Call [[#grants-applyresourceperms]]  with inputs: `DREG`, `SUBJECT`, `MODES`        
1. If `SCOPE` includes only `interop:InheritInstances`
    1. For each [=Data Inheritance=] `INHERITANCE` in `INHERITANCES`
        1. Let `FROMGRANT` be the [=Data Grant=] linked via `INHERITANCE inheritsFrom` 
        1. Let `PROP` be the rdf property extracted from the shape path at
            `INHERITANCE st:traverseViaShapePath`
        1. If `FROMGRANT scopeOfDataGrant` includes `interop:AllInstances`
            1. Let `FROMINSTANCES` be all [=Data Instances=] associated with the 
                [=Data Registration=] linked via `FROMGRANT hasRegistration`
        1. If `FROMGRANT scopeOfDataGrant` includes `interop:SelectedInstances`
            1. Let `FROMINSTANCES` be all [=Data Instances=] associated with the 
                [=Data Registration=] linked via `FROMGRANT hasDataInstance` 
        1. Error if `FROMINSTANCES` is missing
        1. For each [=Data Instance=] `FROMINSTANCE` in `FROMINSTANCES`
            1. Call [[#grants-applyconditionalperms]]  
                with inputs: `DREG`, `SUBJECT`, `MODES`, 
                `FROMINSTANCE`, `PROP`, NULL    
1. If `SCOPE` includes `interop:SelectedInstances`
    1. Let `INSTANCES` be the [=Data Instances=] linked via `DGRANT interop:hasDataInstance`
    1. For each `INSTANCE` in `INSTANCES`
        1. Error if `INSTANCE` is missing
        1. Call [[#grants-applyresourceperms]]  with inputs: `INSTANCE`, `SUBJECT`, `MODES`
1. Return `DGRANT`

</div>

Issue: Append mode for AllInstances needs to be specially handled, and may
require an additional attribute specified in the requested [=Access Needs=]

### Apply Remote Data Permissions ### {#grants-applyremoteperms}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
      This operation applies permissions for a given [=Remote Data Grant=]. 
      It applies to both new and updated [=Remote Data Grants=].
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RDGRANT`</td>
      <td>A validated [=Remote Data Grant=]</td>
    </tr>
    <tr>
      <td>`GRANT`</td>
      <td>A validated [=Access Grant=] that `DGRANT` belongs to</td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>[=Remote Data Grant=]</td>
      <td>That has had the relevant permissions applied</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Let `SUBJECT` be the [=Access Grant Subject=] linked via `GRANT hasAccessGrantSubject`
1. Let `SCOPE` be `RDGRANT scopeOfRemoteDataGrant`
1. Let `MODES` be the [=access modes=] linked via `RDGRANT accessMode`
1. Let `SET` be `RDGRANT hasRemoteDataRegistrationSet`
1. Let `RDRGRANTS` be the [=Remote Data Registration Grants=]
    linked via `RDGRANT hasRemoteDataRegistrationGrant`
1. If `SCOPE` includes `interop:NoAccess`
    1. Call [[#grants-removeresourceperms]] with inputs: `SET`, `SUBJECT`
1. If `SCOPE` is `interop:AllRemote`
    1. Call [[#grants-applyresourceperms]] with inputs: `SET`, `SUBJECT`, `MODES`
1. If `SCOPE` is `interop:SelectedRemote`
    1. For each [=Remote Data Registration Grant=] `RDRGRANT` in `RDRGRANTS`
        1. Call [[#grants-applyremoteregperms]] with inputs: 
            `RDRGRANT`, `RDGRANT`, `GRANT`
1. Return `RDGRANT`

</div>

### Apply Remote Data Registration Permissions ### {#grants-applyremoteregperms}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
      This operation applies permissions for a given 
      [=Remote Data Registration Grant=]. It applies to both new and 
      updated [=Remote Data Registration Grants=].
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RDRGRANT`</td>
      <td>A validated [=Remote Data Registration Grant=]</td>
    </tr>
    <tr>
      <td>`RDGRANT`</td>
      <td>A validated [=Remote Data Grant=]</td>
    </tr>
    <tr>
      <td>`GRANT`</td>
      <td>A validated [=Access Grant=] that `DGRANT` belongs to</td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>[=Remote Data Registration Grant=]</td>
      <td>That has had the relevant permissions applied</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Let `SUBJECT` be `GRANT hasAccessGrantSubject`
1. Let `SCOPE` be `RDRGRANT scopeOfRemoteDataRegistrationGrant`
1. Let `RDREG` be `RDRGRANT hasRemoteDataRegistration`
1. Let `MODES` be the [=access modes=] linked via `RDRGRANT accessMode`
1. Let `INHERITANCES` be the [=Data Inheritances=] linked 
    via `RDRGRANT hasDataInheritance`
1. Let `INSTANCES` be the [=Remote Data Instances=] linked 
    via `RDRGRANT hasRemoteDataInstance`
1. If `SCOPE` is `interop:NoAccess`
    1. Call [[#grants-removeresourceperms]] with inputs: `RDREG`, `SUBJECT`
1. If `SCOPE` is `interop:AllInstances`
    1. Call [[#grants-applyresourceperms]] with inputs: `RDREG`, `SUBJECT`, `MODES`
1. If `SCOPE` is `interop:InheritInstances`
    1. For each [=Data Inheritance=] `INHERITANCE` in `INHERITANCES`
        1. Let `FROMGRANT` be the [=Remote Data Grant=] linked via 
            `INHERITANCE inheritsFrom` 
        1. Let `PROP` be the rdf property extracted from the shape path at
            `INHERITANCE st:traverseViaShapePath`
        1. If `FROMGRANT scopeOfDataGrant` includes `interop:AllInstances`
            1. Let `FROMINSTANCES` be all [=Remote Data Instances=] associated 
                with the [=Remote Data Registration=] linked via 
                `FROMGRANT hasRegistration`
        1. If `FROMGRANT scopeOfDataGrant` includes `interop:SelectedInstances`
            1. Let `FROMINSTANCES` be all [=Remote Data Instances=] associated 
                with the [=Remote Data Registration=] linked via 
                `FROMGRANT hasRemoteDataInstance` 
        1. Error if `FROMINSTANCES` is missing
        1. For each [=Remote Data Instance=] `FROMINSTANCE` in `FROMINSTANCES`
            1. Call [[#grants-applyconditionalperms]]  
                with inputs: `RDREG`, `SUBJECT`, `MODES`, 
                `FROMINSTANCE`, `PROP`, NULL 
1. If `SCOPE` is `interop:SelectedInstances`
    1. For each [=Remote Data Instance=] `INSTANCE` in `INSTANCES`
        1. Call [[#grants-applyresourceperms]] with inputs: `INSTANCE`, `SUBJECT`, `MODES`
1. Return `RDRGRANT`

</div>

### Apply Trusted Permissions ### {#grants-applytrustedperms}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
      This operation applies permissions for a given [=Trusted Grant=]. It applies
      to both new and updated [=Trusted Grants=].
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`TGRANT`</td>
      <td>A validated [=Trusted Grant=]</td>
    </tr>
    <tr>
      <td>`GRANT`</td>
      <td>The validated [=Access Grant=] that `TGRANT` belongs to</td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>[=Trusted Grant=]</td>
      <td>That has had the relevant permissions applied</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Let `SUBJECT` be the [=Access Grant Subject=] `GRANT hasAccessGrantSubject`
1. Let `MODES` be the [=access modes=] linked via `TGRANT accessMode` 
1. If `TGRANT trustedWithType` is `interop:Agent`
    1. Let `PROFILE` be `TGRANT trustedWith`
    1. Call [[#grants-applyresourceperms]]  with inputs: 
        `PROFILE`, `SUBJECT`, `MODES`
1. If `TGRANT trustedWithType` is `interop:RegistrySet`
    1. Let `SET` be `TGRANT trustedWith`
    1. Let `REGISTRIES` be the [=Registries=] linked via `SET hasRegistry`
    1. Call [[#grants-applyresourceperms]]  with inputs: 
        `SET`, `SUBJECT`, `MODES`
    1. For each [=Registry=] `REGISTRY` in `REGISTRIES`
        1. Call [[#grants-applyresourceperms]]  with inputs: 
            `REGISTRY`, `SUBJECT`, `MODES`    
2. If `TGRANT trustedWithType` is `interop:Registry`
    1. Let `REGISTRY` be `TGRANT trustedWith`
    1. Call [[#grants-applyresourceperms]]  with inputs: 
        `REGISTRY`, `SUBJECT`, `MODES`
        
</div>

### Apply Resource Permissions ### {#grants-applyresourceperms}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
      This operation applies permissions on a given resource for a given
      [=Access Grant Subject=]. It clears any existing permissions for
      the [=Access Grant Subject=] first, so that the resultant permissions
      are exactly the ones requested.
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RESOURCE`</td>
      <td>Resource whose permissions will be changed</td>
    </tr>
    <tr>
      <td>`SUBJECT`</td>
      <td>The [=Access Grant Subject=] who the permissions apply to</td>
    </tr>
    <tr>
      <td>`MODES`</td>
      <td>A list of access modes to apply to the resource</td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>Boolean</td>
      <td>Success or Failure</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Call [[#grants-removeresourceperms]] with inputs: `RESOURCE`, `SUBJECT`
1. Add a new [=Authorization Statement=] `NEWSTATEMENT` to `ACL`
1. Set `NEWSTATEMENT` [=Access Grant Subject=] to `SUBJECT`.
1. Set the [=access modes=] for `NEWSTATEMENT` to `MODES`
1. If `RESOURCE` is a container
    1. Set all members of `RESOURCE` to inherit the same permissions

</div>

### Apply Conditional Resource Permissions ### {#grants-applyconditionalperms}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
      This operation applies permissions on a given resource for a given
      [=Access Grant Subject=]. Those permissions are conditioned upon the 
      existence of a graph link between a node in the resource and another node
      in another resource on the same pod.
      
      It clears any existing permissions for
      the [=Access Grant Subject=] first, so that the resultant permissions
      are exactly the ones requested.
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RESOURCE`</td>
      <td>Resource whose permissions will be changed</td>
    </tr>
    <tr>
      <td>`SUBJECT`</td>
      <td>The [=Access Grant Subject=] who the permissions apply to</td>
    </tr>
    <tr>
      <td>`MODES`</td>
      <td>A list of access modes to apply to the resource</td>
    </tr>
    <tr>
      <td>`CONDSUB`</td>
      <td>Subject of conditional link</td>
    </tr>
    <tr>
      <td>`CONDPRED`</td>
      <td>Predicate for conditional link</td>
    </tr>
    <tr>
      <td>`CONDOBJ`</td>
      <td>Object for conditional link</td>
    </tr>  
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>Boolean</td>
      <td>Success or Failure</td>
    </tr>
  </tbody>
</table>

Issue: Need to determine how to deal with objects that are
dynamic, where we need to match against more than one resource and
the subject identifier could? vary

<div class="opdetails">

1. Call [[#grants-removeresourceperms]] with inputs: `RESOURCE`, `SUBJECT`
1. Add a new [=Authorization Statement=] `NEWSTATEMENT` to `ACL`
1. Set `NEWSTATEMENT` [=Access Grant Subject=] to `SUBJECT`
1. Set a condition on `NEWSTATEMENT` that access is only permitted when
    a graph link is present composed of 
    subject: `CONDSUB`, predicate: `CONDPRED`, object: `CONDOBJ`
1. Set the [=access modes=] for `NEWSTATEMENT` to `MODES`
1. If `RESOURCE` is a container
    1. Set all members of `RESOURCE` to inherit the same permissions

</div>

### Remove Resource Permissions ### {#grants-removeresourceperms}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
      This operation removes permissions on a given resource for a given
      [=Access Grant Subject=].
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RESOURCE`</td>
      <td>Resource whose permissions will be changed</td>
    </tr>
    <tr>
      <td>`SUBJECT`</td>
      <td>The [=Access Grant Subject=] who the permissions apply to</td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>Boolean</td>
      <td>Success or Failure</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Let `ACL` be the [=ACL Resource=] directly associated with `RESOURCE`
1. Let `STATEMENTS` be any [=Authorization Statements=] in `ACL` directly
    associated with `SUBJECT`.
1. For each `STATEMENT` in `STATEMENTS`
    1. Remove [=Access Grant Subject=] from `STATEMENT`
    2. Remove `STATEMENT` if there are no remaining [=Access Grant Subjects=]

</div>

### Present Access Grant ### {#grants-present-access}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
      This operation is non-normative, and meant to instruct
      a developer in how to load and initialize an [=Access Grant=], 
      present it to an [=Agent=], invoke the appropriate
      operations to manipulate [=Data Grants=], [=Remote Data Grants=], 
      or [=Trusted Grants=] in 
      accordance with the [=Agent's=] decisions, and then record and act 
      upon those decisions.
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`SUBJECT`</td>
      <td>An [=Access Grant Subject=]</td>
    </tr>
    <tr>
      <td>`REGISTRY`</td>
      <td>An [=Access Grant Registry=]</td>
    </tr>
    <tr>
      <td>`GROUPS`</td>
      <td>An optional set of [=Access Need Groups=]</td>
    </tr>
    <tr>
      <td>`LANG`</td>
      <td>The [=Agent's=] preferred language</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Let `GRANT` be an [=Access Grant=] returned by [[#grants-loadgrant]] with
    inputs: `SUBJECT`, `REGISTRY`
1. If `GRANT` is missing, let `GRANT` be an [=Access Grant=] returned
    by [[#grants-initializegrant]] with inputs: `SUBJECT`, `REGISTRY`,
    `GROUPS`, `LANG`.
1. If available, present the [=Agent=] who granted access via `registeredBy`
1. If available, present the [=Application=] used by the [=Agent=] to grant
    access via `registeredWith`
1. If available, present the timestamp of creation via `registeredAt`,
    and update via `updatedAt`
1. For each [=Compiled Access Group=] `CAGROUP` in `CAGROUPS`
    1. Call [[#grants-present-cagroup]] with inputs: 
        `CAGROUP`, `GRANT`, `REGISTRY`, `LANG`
1. Call [[#grants-recordgrant]] with inputs: `GRANT`, `REGISTRY`

</div>

### Present Access Invitation ### {#grants-present-invitation}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
      This operation is non-normative, and meant to instruct
      a developer in how to load and initialize an [=Access Invitation=], 
      present it to an [=Agent=], invoke the appropriate
      operations to manipulate [=Data Grants=], [=Remote Data Grants=], 
      or [=Trusted Grants=] in 
      accordance with the [=Agent's=] decisions, and then record and act 
      upon those decisions.
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`TARGET`</td>
      <td>The `interop:channelTarget` of an [=Access Invitation=]</td>
    </tr>
    <tr>
      <td>`ICHANNELS`</td>
      <td>A set of [=Access Invitation Channels=] for a new
      [=Access Invitation=]</td>
    </tr>
    <tr>
      <td>`REGISTRY`</td>
      <td>An [=Access Grant Registry=]</td>
    </tr>
    <tr>
      <td>`GROUPS`</td>
      <td>An optional set of [=Access Need Groups=]</td>
    </tr>
    <tr>
      <td>`LANG`</td>
      <td>The [=Agent's=] preferred language</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Let `INVITATION` be an [=Access Invitation=] returned by
    [[#grants-loadinvitation]] with inputs: `TARGET`, `REGISTRY`
1. If `INVITATION` is missing, let `INVITATION` be an [=Access Invitation=]
    returned by [[#grants-initializegrant]] with inputs: `ICHANNELS`,
    `REGISTRY`, `GROUPS`, `LANG`
1. Let `CAGROUPS` be the [=Compiled Access Groups] linked via `GRANT hasCompiledAccessGroup`
1. If available, present the [=Agent=] who granted access via `registeredBy`
1. If available, present the [=Application=] used by the [=Agent=] to grant
    access via `registeredWith`
1. If available, present the timestamp of creation via `registeredAt`,
    and update via `updatedAt`
1. For each [=Compiled Access Group=] `CAGROUP` in `CAGROUPS`
    1. Call [[#grants-present-cagroup]] with inputs: 
        `CAGROUP`, `INVITATION`, `REGISTRY`, `LANG`
1. Call [[#grants-recordinvitation]] with inputs: `INVITATION`, `REGISTRY`

</div>

### Present Compiled Access Group #### {#grants-present-cagroup}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
      This operation is used to present a [=Compiled Access Group=] to
      an [=Agent=] for the purposes of reviewing and managing the
      [=Data Grants], [=Remote Data Grants=], and [=Trusted Grants=]
      associated with an [=Access Grant=] or [=Access Invitation=].
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`CAGROUP`</td>
      <td>A [=Compiled Access Group=] associated with `GRANT`</td>
    </tr>
    <tr>
      <td>`GRANT`</td>
      <td>The [=Access Grant=] or [=Access Invitation=] that `CAGROUP`
      is associated with.
      </td>
    </tr>
    <tr>
      <td>`REGISTRY`</td>
      <td>An [=Access Grant Registry=]</td>
    </tr>
    <tr>
      <td>`LANG`</td>
      <td>The [=Agent's=] preferred language</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Let `GDEC` be the [=Access Need Group Decorator=] linked via
    `CAGROUP hasAccessNeedGroupDecorator`
1. Let `GROUPNAME` be `GDEC skos:prefLabel`
1. Let `GROUPDESC` be `GDEC skos:definition` 
1. Let `GRANTEETYPE` be  `CAGROUP authenticatesAs`
1. Let `GROUPREQUIRED` be `true` if `CAGROUP accessNecessity` is 
    `interop:AccessRequired`
1. Let `ENABLEOPTIONAL` be `true` if `CAGROUP accessNecessity` is 
    `interop:AccessOptional` and `CAGROUP isEnabled` is `true`
1. If `ENABLEOPTIONAL` is not `true` 
    1. Present an option to enable the group by letting `CAGROUP isEnabled`
        be `true`, and let `ENABLEOPTIONAL` be `true`
1. If `GROUPREQUIRED` is `true` or `ENABLEOPTIONAL` is `true`
    1. To disable the group call [[#grants-denygroup]] operation with 
            inputs: `GRANT`, `CAGROUP`
    1. For each [=Root Compiled Access=] `ROOT` linked via
        `CAGROUP hasCompiledAccess`
        1. Call [[#grants-present-root-ca]] with inputs:
            `ROOT`, `CAGROUP`, `GRANT`, `LANG`

</div>

### Present Root Compiled Access ### {#grants-present-root-ca}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
      This option is used to present a [=Root Compiled Access=] in a
      [=Compiled Access Group=].
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`ROOT`</td>
      <td>The Root [=Compiled Access=] to present</td>
    </tr>
    <tr>
      <td>`CAGROUP`</td>
      <td>The [=Compiled Access Group=] that `CACCESS` belongs to</td>
    </tr>
    <tr>
      <td>`GRANT`</td>
      <td>The [=Access Grant=] that `CAGROUP` belongs to</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Call [[#grants-present-ca-details]] with inputs: 
    `ROOT`, `CAGROUP`, `GRANT`    
    
1. For each [=Compiled Access=] `CACCESS` starting with `ROOT`
    and traversed via `CACCESS skos:narrower` or
    `CACCESS referencesCompiledAccess`:
    
    1. If `DATAGRANT scopeOfDataGrant` is `interop:NoAccess`
        1. Allow `interop:AllInstances` to be selected, which invokes
            the [[#grants-selectall]] operation with inputs:
            `GRANT`, `CAGROUP`, `CACCESS`
        1. Allow a subset of [=Data Instances=] be selected,
            and let `INSTANCES` be that subset, invoking
            the [[#grants-select]] operation with inputs:
            `INSTANCES`, `GRANT`, `CAGROUP`, `CACCESS`
    1. If `DATAGRANT scopeOfDataGrant` is `interop:AllInstances`, then
        present the user with summary details, and the ability to
        see specific instances.
            1. Let `INSTANCES` be a selected set of
                [=Data Instances=]
            1. If the user chooses to select
                specific instances from this list, invoke the
                [[#grants-select]] operation with inputs: `INSTANCES`,
                `GRANT`, `CAGROUP`, `CACCESS`.
    1. If `DATAGRANT scopeOfDataGrant` is `interop:SelectedInstances`, then
        present the user with the specific instances they have selected,
        and:
            1. Let `INSTANCES` be a selected set of
                [=Data Instances=]
            1. Allow the selected [=Data Instances=] to be
                adjusted, and invoke the [[#grants-select]] operation with
                inputs: `INSTANCES`, `DATAGRANT`, `CAGROUP`, `CACCESS`.
            1. Allow all [=Data Instances=] to be selected,
                invoking the [[#grants-selectall]] operation with inputs:
                `GRANT`, `CAGROUP`, `CACCESS`.
    1. If `DATAGRANT scopeOfDataGrant` is `interop:InheritInstances`, present
        the inherited [=Data Instances=] and:
        1. Let `INSTANCES` be a selected set of
            [=Data Instances=]
        1. Allow a subset to be selected, invoking
            the [[#grants-select]] operation with inputs: `INSTANCES`,
            `GRANT`, `CAGROUP`, `CACCESS`
        1. Identify the [=Compiled Access=] / [=Data Grant=]
            and selected [=Data Instances=] that were inherited
            from.
    1. If `DATAGRANT scopeOfDataGrant` includes `interop:SelectedInstances`
        and `interop:InheritInstances`
        1. Let `INSTANCES` be a selected set of
            [=Data Instances=]
        1. Give the ability to adjust the selected instances, invoking
            the [[#grants-select]] operation with inputs:
            `INSTANCES`, `GRANT`, `CAGROUP`, `CACCESS`.
        1. Give the ability to revert to all inherited instances,
            invoking the [[#grants-selectall]] operation with inputs:
            `GRANT`, `CAGROUP`, `CACCESS`

</div>

### Present Compiled Access Details ### {#grants-present-ca-details}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
      This option is used to present the details of a [=Compiled Access=].
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`CACCESS`</td>
      <td>The Root [=Compiled Access=] to present</td>
    </tr>
    <tr>
      <td>`CAGROUP`</td>
      <td>The [=Compiled Access Group=] that `CACCESS` belongs to</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Let `DATAGRANT` be `CACCESS hasDataGrant`
1. Let `ANDEC` be `CACCESS hasAccessNeedDecorator`
1. Let `STDEC` be `CACCESS hasShapeTreeDecorator`
1. If `CACCESS accessNecessity` is `AccessOptional`,
    and `DATAGRANT scopeOfDataGrant` is `interop:NoAccess`
    1. Allow access selection to be enabled and managed as detailed
        in the remainder of this operation.
1. Present the name of the [=shape tree=] via `STDEC skos:prefLabel`
1. Present the reason access to this data is needed via
    `ANDEC skos:prefLabel`
1. Present the access modes requested via `CACCESS accessMode`s
1. For each supporting [=Compiled Access=] `SUPPORTING` linked
    via `CACCESS supportedBy`
    1. Present the name of the [=shape tree=] via the
        associated [=Shape Tree Decorator=]
    1. Present the reason access to this data is needed via the
        associated [=Access Need Decorator=]
    1. Present the access modes requested via
        `SUPPORTING accessMode`s
        
</div>

### Deny Compiled Access Group ### {#grants-denygroup}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
      This operation is used when a given [=Compiled Access Group=] with 
      optional necessity has been denied.
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`GRANT`</td>
      <td>An [=Access Grant=]</td>
    </tr>
    <tr>
      <td>`CAGROUP`</td>
      <td>A [=Compiled Access Group=]</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Let `CAGROUP isEnabled` be `false` if `CAGROUP accessNecessity` is
    `interop:AccessOptional`
1. For each [=Compiled Access=] `CACCESS` in `CAGROUP`
    1. Let `DATAGRANT` be `CACCESS hasDataGrant`
    1. Let `DATAGRANT scopeOfDataGrant` be `interop:NoAccess`

</div>

### Select Specific Instances for Access ### {#grants-select}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>      
      Used to select specific [=Data Instances=] for a given
      [=Data Grant=], which has a recursive application down the hierachy,
      with subordinate [=Data Grants=] reducing their associated scope of
      [=Data Instances=] to only those related to the instances above them.
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`INSTANCES`</td>
      <td>A set of [=Data Instances=] selected for access</td>
    </tr>
    <tr>
      <td>`DATAGRANT`</td>
      <td>The [=Data Grant=] that `INSTANCES` are associated with</td>
    </tr>
    <tr>
      <td>`GRANT`</td>
      <td>The [=Access Grant=] that `DATAGRANT` is associated with</td>
    </tr>    
  </tbody>
</table>

<div class="opdetails">


</div>




### Select All Instances for Access ### {#grants-selectall}

Used to select all [=Data Instances=] for a given [=Data Grant=].
In the event where this is moving from a subset of inherited instances,
this will expand to only include all inherited instances.

Issue: Write operation for selecting all Data Instances
for a given Data Registration within an Access Grant

### Load Trusted Agent ### {#trusted-load}

Issue: Write operation for Load Trusted Agent

### Create Trusted Agent ### {#trusted-create}

Issue: Write operation for Create Trusted Agent

### Delete Trusted Agent ### {#trusted-delete}

Issue: Write operation for Delete Trusted Agent

### Redirect to Trusted Agent ### {#trusted-redirect}

Issue: Remove this and replace with routine for specific application service

### Return from Trusted Agent ### {#trusted-return}

Issue: Remove this and replace with routine for specific application service
